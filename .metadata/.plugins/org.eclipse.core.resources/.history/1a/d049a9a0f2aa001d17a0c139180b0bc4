/*
 * selection_sort.s
 *
 *  Created on: 19/1/2022
 *      Author: Ni Qingqing
 */
   .syntax unified
	.cpu cortex-m4
	.fpu softvfp
	.thumb

		.global selection_sort

@ Start of executable code
.section .text

@ EE2028 Assignment 1, Sem 2, AY 2022/23
@ (c) ECE NUS, 2023
@ Selection sort arr in ascending order

@ Write Student 1’s Name here: Clinton Yong Tzen Wei
@ Write Student 2’s Name here: Chua Wei Xuan

@ Look-up table of registers:
@ R0 Pointer pointing to the start (first element) of array > Pointer pointing to the array's first element to be checked for nth iteration
@ R1 Length of array > Offset to the end (last element) of array > Pointer pointing to the end (last element) of array
@ R2 Current value of element in array checked
@ R3 Smallest value of element checked
@ R4 Pointer pointing to the current element in array checked
@ R5 Pointer pointing to the smallest value of element checked
@ R6 Number of iterations
@ R14 Link Register
@ function will add offset at the end, and check if loop is over at the end

@ write your program from here:
selection_sort:
	@ R0 is the first parameter of selection_sort function -> Pointer pointing to the start of array
	@ R1 is the second parameter of selection_sort function -> Length of array
	@ Retaining (PUSH) R0-R3 is not needed as R0-R3 are caller-saved registers
	@ Retaining (PUSH) existing data from R4-R6 and Link Register (R14) into stack
	PUSH {R4, R5, R6, R14}

	@ Number of iterations (R6) <- Length of array (R1) - 1
	SUB R6, R1, #1

	@ Offset to the end of array (R1) <- (Length of array (R1) - 1) * 4
	MOV R2, #4
	MUL R1, R6, R2

	@ Pointer pointing to the end of array (R1) <- Offset to the end of array (R1) + Pointer pointing to the start of array (R0)
	ADD R1, R0

	@ Branching with link to SUBROUTINE function
	@ SUBROUTINE now has R0 as Pointer pointing to the start of array and R1 as Pointer pointing to the end of array
	BL SUBROUTINE


	@ Moving Number of iterations (R6) into R0 to be returned in selection_sort function
	MOV R0, R6

	@ selection_sort completed, going back to the main program, Retrieveing (POP) data from R4-R6 and R15 (Program Counter) from stack
	POP {R4, R5, R6, R15}

SUBROUTINE:
	@ Start of checking
	@ Loading the value of array's first element to be checked for this iteration ([R0]) into R3 (Smallest value of element checked)
	LDR R3, [R0]

	@ Moving Pointer pointing to the array's first element to be checked for this iteration (R0) into R5 (Pointer pointing to the smallest value of element checked)
	MOV R5, R0

	@ Moving Pointer pointing to the array's first element to be checked for this iteration (R0) into R4 (Pointer pointing to the current element in array checked)
	MOV R4, R0

	check_array:
		@ Shifting R4 (Pointer pointing to the current element in array) up by one position
		ADD R4, #4

		@ Loading value of current element in array checked ([R4]) into R2 (Current value of element in array checked)
		LDR R2, [R4]

		@ branch to LARGER_NUM function if R2 (Current value of element in array checked) is greater than or equal to R3 (Smallest value of element checked)
		CMP R2, R3
		BGE LARGER_NUM

		@ Moving Current value of element in array checked (R2) into R3 (Smallest value of element checked)
		MOV R3, R2

		@ Moving Pointer pointing to the current element in array checked (R4) into R5 (Pointer pointing to the smallest value of element checked)
		MOV R5, R4

		LARGER_NUM:
			@ Branching back to check_array function if R4 (Pointer pointing to the current element in array) is equal to R1 (Pointer pointing to the end of array)
			CMP R4, R1
			BNE check_array

	@ Swapping the smallest value identified in this iteration
	@ Loading the value of array's first element to be checked for this iteration ([R0]) into R4 (used as a temporary storage)
	LDR R4, [R0]

	@ Storing the Smallest value of element checked (R3) into the value of array's first element to be checked for this iteration ([R0])
	STR R3, [R0]

	@ Storing the value of array's first element to be checked for this iteration in the temporary storage (R4) into the previous position of array's smallest element ([R5]
	STR R4, [R5]

	@ Shifting the value of R0 up by one position
	ADD R0, #4

	@ Looping back to SUBROUTINE if not yet at last position (R0 not equal to R1)
	CMP R0, R1
	BNE SUBROUTINE

	@return back to selection_sort
	BX R14



